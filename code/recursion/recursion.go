package main

import "fmt"

/*
递归：是一种算法策略，通过函数调用自身来解决问题。主要包含两个阶段：
1. 递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。
2. 归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。
1. 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会释放。因此递归会比迭代更耗费内存空间。
2.递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。
*/
func recur(n int) int {
	// 终止条件
	if n == 1 {
		return 1
	}
	// 递：递归调用自身
	res := recur(n - 1)
	// 归：返回结果
	return n + res
}

/*
尾递归：递归函数的返回值依赖于函数的参数，并且函数没有后续操作。这种递归称为尾递归。
尾递归是一种优化递归的策略，它通过将递归调用作为函数的最后一步来避免创建额外的栈帧。
1. 普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
2. 尾递归：当函数返回到上一层级的函数后，不需要继续执行代码，因此系统不需要保存上一层调用的上下文。
*/

func tailRecur(n int, res int) int {
	// 终止条件
	if n == 0 {
		return res
	}
	return tailRecur(n-1, res+n)
}

/*
递归树：递归函数调用的树状结构，每个节点代表一个函数调用。
*/

/*
斐波那契数列：给定一个斐波那契数列 0,1,1,2,3,5,8,13....，求第n个数。
设斐波那契数列的第n个数字为F(n)，易得两个结论。
1. 数列的前2个数字为F(1)=0,F(2)=1
2. 数列的第n个数字为F(n)=F(n-1)+F(n-2)
*/
func fib(n int) int {
	// 终止条件
	if n == 1 || n == 2 {
		return n - 1
	}
	res := fib(n-1) + fib(n-2)
	return res
}

func main() {
	res := recur(5)
	tailRes := tailRecur(5, 0)
	fibRes := fib(5)
	fmt.Println(res)
	fmt.Println(tailRes)
	fmt.Println(fibRes)
}
